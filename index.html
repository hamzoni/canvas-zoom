<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        .container {
            background: #eee;
            width: 800px;
            height: 500px;
            float: left;
            overflow: hidden;
        }
    </style>
</head>
<body>

<div class="container">
    <canvas id="canvas"></canvas>
</div>

<script>
    const image = new Image;
    image.src = "https://upload.wikimedia.org/wikipedia/commons/thumb/6/6d/KTZ_2TE10U_Aynabulak.jpg/800px-KTZ_2TE10U_Aynabulak.jpg";
    let w, h, cw, ch, canvas, ctx;

    const font = {
        font: "28px Arial",
        textAlign: "center",
        textBaseline: "middle",
    };

    function setStyle(ctx, style) {
        Object.keys(style).forEach(key => ctx[key] = style[key]);
    }

    class CanvasDrag {
        dragging = false;
        lastX = 0;
        lastY = 0;
        view = null;
        mouse = null;


        constructor() {
        }

        setView(view) {
            this.view = view;
        }

        setMouse(mouse) {
            this.mouse = mouse;
        }

        update() {
            let dx, dy;
            if (this.mouse.w) {
                if (this.mouse.w < 0) {
                    this.mouse.w += 10;
                    this.view.scaleAt(this.mouse.x, this.mouse.y, 1 / 1.02);
                    if (this.mouse.w > 0) {
                        this.mouse.w = 0;
                    }
                } else if (this.mouse.w > 0) {
                    this.mouse.w -= 10;
                    this.view.scaleAt(this.mouse.x, this.mouse.y, 1.02);
                    if (this.mouse.w < 0) {
                        this.mouse.w = 0;
                    }
                }
            }
            if (this.mouse.buttonRaw) {
                if (!this.dragging) {
                    this.dragging = true;
                    this.lastX = this.mouse.x;
                    this.lastY = this.mouse.y;
                } else {
                    if (this.mouse.buttonRaw & 1) {
                        dx = this.mouse.x - this.lastX;
                        dy = this.mouse.y - this.lastY;
                        this.lastX = this.mouse.x;
                        this.lastY = this.mouse.y;
                        this.view.movePos(dx, dy);
                    }
                }
            } else {
                if (this.dragging) {
                    this.dragging = false;
                }
            }
        }
    }

    class CanvasView {

        // current view transform
        matrix = [1, 0, 0, 1, 0, 0];

        rotate = 0;
        scale = 1;
        pos = {
            x: 0, y: 0,
        };
        dirty = true;
        master = null;

        constructor(master) {
            this.master = master;
        }

        apply(ctx) {
            if (this.dirty) this.update();
            let m = this.matrix;
            ctx.setTransform(m[0], m[1], m[2], m[3], m[4], m[5]);
        }

        update() { // call to update transforms
            const r = this.rotate;
            const s = this.scale;

            let xdx = Math.cos(r) * s;
            let xdy = Math.sin(r) * s;

            // calculate the inverse transformation
            this.matrix = [xdx, xdy, -xdy, xdx, this.pos.x, this.pos.y];
            this.dirty = false;
        }


        movePos(x, y) {
            this.pos.x += x;
            this.pos.y += y;
            this.dirty = true;
        }

        scaleAt(x, y, sc) {
            if (this.dirty) {
                this.update()
            }
            this.scale *= sc;
            this.pos.x = x - (x - this.pos.x) * sc;
            this.pos.y = y - (y - this.pos.y) * sc;
            this.dirty = true;
        }

        display() { // call once per frame

            ctx.setTransform(1, 0, 0, 1, 0, 0); // reset transform
            ctx.globalAlpha = 1; // reset alpha
            ctx.clearRect(0, 0, w, h);

            this.master.checkKeyMovement();

            this.master.drag.update();
            if (image.complete) {
                this.apply(ctx);
                ctx.drawImage(image, 0, 0);
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.fillText("Click drag to pan. Wheel to zoom or left/right arrow.", cw, 20)
            } else {
                ctx.fillText("Loading Image...", cw, ch)
            }

        }

    }

    class CanvasMouse {

        x = 0;
        y = 0;
        buttonRaw = 0;
        buttonOnMasks = [0b1, 0b10, 0b100];
        buttonOffMasks = [0b110, 0b101, 0b011];
        active = false;
        eventNames = 'mousemove,mousedown,mouseup,mouseout,mouseover,mousewheel,DOMMouseScroll'.split(',');

        event(e, m) {
            const t = e.type;
            m.bounds = m.element.getBoundingClientRect();
            m.x = e.pageX - m.bounds.left - scrollX;
            m.y = e.pageY - m.bounds.top - scrollY;

            if (t === 'mousedown') {
                m.buttonRaw |= m.buttonOnMasks[e.which - 1]
            } else if (t === 'mouseup') {
                m.buttonRaw &= m.buttonOffMasks[e.which - 1]
            } else if (t === 'mouseout') {
                m.over = false
            } else if (t === 'mouseover') {
                m.over = true
            } else if (t === 'mousewheel') {
                m.w = e.wheelDelta;
                e.preventDefault();
            } else if (t === 'DOMMouseScroll') {
                m.w = -e.detail;
                e.preventDefault();
            }
        }

        down() {
            this.w += 10;
        }

        up() {
            this.w -= 10;
        }

        start(element) {
            this.element = element === undefined ? document : element;
            this.eventNames.forEach(name => document.addEventListener(name, e => {
                this.event(e, this);
            }));
            document.addEventListener("contextmenu", e => {
                e.preventDefault()
            }, false);
            this.active = true;
        }
    }


    function onResize() {
        setStyle(ctx, font);
    }


    class CanvasAnimation {
        RESIZE_DEBOUNCE_TIME = 100;
        resizeTimeoutHandle = null;
        firstRun = true;
        globalTime = 0;

        mouse = new CanvasMouse();
        drag = new CanvasDrag();
        view = null;

        keys = [];

        keyEvent(e) {
            this.keys[e.code] = e.type === 'keydown';
        }

        constructor() {
            ['keydown', 'keyup'].forEach(k => {
                document.addEventListener(k, e => {
                    this.keyEvent(e);
                });
            });

            this.view = new CanvasView(this);
            this.drag.setView(this.view);
            this.drag.setMouse(this.mouse);

            canvas = this.createCanvas();
            this.mouse.start(canvas, true);
            this.resizeCanvas();
            window.addEventListener("resize", this.resizeCanvas);
            requestAnimationFrame(t => {
                this.update(t, this);
            });
        }

        checkKeyMovement() {
            if (this.keys.ArrowLeft) {
                this.mouse.down();
            }

            if (this.keys.ArrowRight) {
                this.mouse.up();
            }
        }

        createCanvas() {
            return document.getElementById('canvas');
        }

        resizeCanvas() {
            if (canvas === undefined) {
                canvas = this.createCanvas()
            }
            canvas.width = innerWidth;
            canvas.height = innerHeight;
            ctx = canvas.getContext("2d");

            cw = (w = canvas.width) / 2;
            ch = (h = canvas.height) / 2;

            if (typeof onResize === "function") {
                clearTimeout(this.resizeTimeoutHandle);
                if (this.firstRun) {
                    onResize()
                } else {
                    this.resizeTimeoutHandle = setTimeout(onResize, this.RESIZE_DEBOUNCE_TIME)
                }
                this.firstRun = false;
            }
        }

        update(timer, vm) { // Main update loop
            if (!this.view) return;

            vm.globalTime = timer;
            vm.view.display();           // call demo code
            requestAnimationFrame(t => {
                this.update(t, vm);
            })
        }

    }

    new CanvasAnimation();
</script>
</body>
</html>
